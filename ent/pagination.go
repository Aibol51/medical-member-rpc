// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/suyuan32/simple-admin-member-rpc/ent/appointment"
	"github.com/suyuan32/simple-admin-member-rpc/ent/expert"
	"github.com/suyuan32/simple-admin-member-rpc/ent/medicalrecord"
	"github.com/suyuan32/simple-admin-member-rpc/ent/medicine"
	"github.com/suyuan32/simple-admin-member-rpc/ent/member"
	"github.com/suyuan32/simple-admin-member-rpc/ent/memberrank"
	"github.com/suyuan32/simple-admin-member-rpc/ent/news"
	"github.com/suyuan32/simple-admin-member-rpc/ent/oauthprovider"
	"github.com/suyuan32/simple-admin-member-rpc/ent/service"
	"github.com/suyuan32/simple-admin-member-rpc/ent/swiper"
	"github.com/suyuan32/simple-admin-member-rpc/ent/token"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type AppointmentPager struct {
	Order  appointment.OrderOption
	Filter func(*AppointmentQuery) (*AppointmentQuery, error)
}

// AppointmentPaginateOption enables pagination customization.
type AppointmentPaginateOption func(*AppointmentPager)

// DefaultAppointmentOrder is the default ordering of Appointment.
var DefaultAppointmentOrder = Desc(appointment.FieldID)

func newAppointmentPager(opts []AppointmentPaginateOption) (*AppointmentPager, error) {
	pager := &AppointmentPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultAppointmentOrder
	}
	return pager, nil
}

func (p *AppointmentPager) ApplyFilter(query *AppointmentQuery) (*AppointmentQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// AppointmentPageList is Appointment PageList result.
type AppointmentPageList struct {
	List        []*Appointment `json:"list"`
	PageDetails *PageDetails   `json:"pageDetails"`
}

func (a *AppointmentQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...AppointmentPaginateOption,
) (*AppointmentPageList, error) {

	pager, err := newAppointmentPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.ApplyFilter(a); err != nil {
		return nil, err
	}

	ret := &AppointmentPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := a.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		a = a.Order(pager.Order)
	} else {
		a = a.Order(DefaultAppointmentOrder)
	}

	a = a.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type ExpertPager struct {
	Order  expert.OrderOption
	Filter func(*ExpertQuery) (*ExpertQuery, error)
}

// ExpertPaginateOption enables pagination customization.
type ExpertPaginateOption func(*ExpertPager)

// DefaultExpertOrder is the default ordering of Expert.
var DefaultExpertOrder = Desc(expert.FieldID)

func newExpertPager(opts []ExpertPaginateOption) (*ExpertPager, error) {
	pager := &ExpertPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultExpertOrder
	}
	return pager, nil
}

func (p *ExpertPager) ApplyFilter(query *ExpertQuery) (*ExpertQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ExpertPageList is Expert PageList result.
type ExpertPageList struct {
	List        []*Expert    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (e *ExpertQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...ExpertPaginateOption,
) (*ExpertPageList, error) {

	pager, err := newExpertPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.ApplyFilter(e); err != nil {
		return nil, err
	}

	ret := &ExpertPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := e.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		e = e.Order(pager.Order)
	} else {
		e = e.Order(DefaultExpertOrder)
	}

	e = e.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type MedicalRecordPager struct {
	Order  medicalrecord.OrderOption
	Filter func(*MedicalRecordQuery) (*MedicalRecordQuery, error)
}

// MedicalRecordPaginateOption enables pagination customization.
type MedicalRecordPaginateOption func(*MedicalRecordPager)

// DefaultMedicalRecordOrder is the default ordering of MedicalRecord.
var DefaultMedicalRecordOrder = Desc(medicalrecord.FieldID)

func newMedicalRecordPager(opts []MedicalRecordPaginateOption) (*MedicalRecordPager, error) {
	pager := &MedicalRecordPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultMedicalRecordOrder
	}
	return pager, nil
}

func (p *MedicalRecordPager) ApplyFilter(query *MedicalRecordQuery) (*MedicalRecordQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// MedicalRecordPageList is MedicalRecord PageList result.
type MedicalRecordPageList struct {
	List        []*MedicalRecord `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (mr *MedicalRecordQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...MedicalRecordPaginateOption,
) (*MedicalRecordPageList, error) {

	pager, err := newMedicalRecordPager(opts)
	if err != nil {
		return nil, err
	}

	if mr, err = pager.ApplyFilter(mr); err != nil {
		return nil, err
	}

	ret := &MedicalRecordPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := mr.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		mr = mr.Order(pager.Order)
	} else {
		mr = mr.Order(DefaultMedicalRecordOrder)
	}

	mr = mr.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := mr.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type MedicinePager struct {
	Order  medicine.OrderOption
	Filter func(*MedicineQuery) (*MedicineQuery, error)
}

// MedicinePaginateOption enables pagination customization.
type MedicinePaginateOption func(*MedicinePager)

// DefaultMedicineOrder is the default ordering of Medicine.
var DefaultMedicineOrder = Desc(medicine.FieldID)

func newMedicinePager(opts []MedicinePaginateOption) (*MedicinePager, error) {
	pager := &MedicinePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultMedicineOrder
	}
	return pager, nil
}

func (p *MedicinePager) ApplyFilter(query *MedicineQuery) (*MedicineQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// MedicinePageList is Medicine PageList result.
type MedicinePageList struct {
	List        []*Medicine  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (m *MedicineQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...MedicinePaginateOption,
) (*MedicinePageList, error) {

	pager, err := newMedicinePager(opts)
	if err != nil {
		return nil, err
	}

	if m, err = pager.ApplyFilter(m); err != nil {
		return nil, err
	}

	ret := &MedicinePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		m = m.Order(pager.Order)
	} else {
		m = m.Order(DefaultMedicineOrder)
	}

	m = m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type MemberPager struct {
	Order  member.OrderOption
	Filter func(*MemberQuery) (*MemberQuery, error)
}

// MemberPaginateOption enables pagination customization.
type MemberPaginateOption func(*MemberPager)

// DefaultMemberOrder is the default ordering of Member.
var DefaultMemberOrder = Desc(member.FieldID)

func newMemberPager(opts []MemberPaginateOption) (*MemberPager, error) {
	pager := &MemberPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultMemberOrder
	}
	return pager, nil
}

func (p *MemberPager) ApplyFilter(query *MemberQuery) (*MemberQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// MemberPageList is Member PageList result.
type MemberPageList struct {
	List        []*Member    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (m *MemberQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...MemberPaginateOption,
) (*MemberPageList, error) {

	pager, err := newMemberPager(opts)
	if err != nil {
		return nil, err
	}

	if m, err = pager.ApplyFilter(m); err != nil {
		return nil, err
	}

	ret := &MemberPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := m.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		m = m.Order(pager.Order)
	} else {
		m = m.Order(DefaultMemberOrder)
	}

	m = m.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type MemberRankPager struct {
	Order  memberrank.OrderOption
	Filter func(*MemberRankQuery) (*MemberRankQuery, error)
}

// MemberRankPaginateOption enables pagination customization.
type MemberRankPaginateOption func(*MemberRankPager)

// DefaultMemberRankOrder is the default ordering of MemberRank.
var DefaultMemberRankOrder = Desc(memberrank.FieldID)

func newMemberRankPager(opts []MemberRankPaginateOption) (*MemberRankPager, error) {
	pager := &MemberRankPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultMemberRankOrder
	}
	return pager, nil
}

func (p *MemberRankPager) ApplyFilter(query *MemberRankQuery) (*MemberRankQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// MemberRankPageList is MemberRank PageList result.
type MemberRankPageList struct {
	List        []*MemberRank `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

func (mr *MemberRankQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...MemberRankPaginateOption,
) (*MemberRankPageList, error) {

	pager, err := newMemberRankPager(opts)
	if err != nil {
		return nil, err
	}

	if mr, err = pager.ApplyFilter(mr); err != nil {
		return nil, err
	}

	ret := &MemberRankPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := mr.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		mr = mr.Order(pager.Order)
	} else {
		mr = mr.Order(DefaultMemberRankOrder)
	}

	mr = mr.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := mr.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type NewsPager struct {
	Order  news.OrderOption
	Filter func(*NewsQuery) (*NewsQuery, error)
}

// NewsPaginateOption enables pagination customization.
type NewsPaginateOption func(*NewsPager)

// DefaultNewsOrder is the default ordering of News.
var DefaultNewsOrder = Desc(news.FieldID)

func newNewsPager(opts []NewsPaginateOption) (*NewsPager, error) {
	pager := &NewsPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultNewsOrder
	}
	return pager, nil
}

func (p *NewsPager) ApplyFilter(query *NewsQuery) (*NewsQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// NewsPageList is News PageList result.
type NewsPageList struct {
	List        []*News      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (n *NewsQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...NewsPaginateOption,
) (*NewsPageList, error) {

	pager, err := newNewsPager(opts)
	if err != nil {
		return nil, err
	}

	if n, err = pager.ApplyFilter(n); err != nil {
		return nil, err
	}

	ret := &NewsPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := n.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		n = n.Order(pager.Order)
	} else {
		n = n.Order(DefaultNewsOrder)
	}

	n = n.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type OauthProviderPager struct {
	Order  oauthprovider.OrderOption
	Filter func(*OauthProviderQuery) (*OauthProviderQuery, error)
}

// OauthProviderPaginateOption enables pagination customization.
type OauthProviderPaginateOption func(*OauthProviderPager)

// DefaultOauthProviderOrder is the default ordering of OauthProvider.
var DefaultOauthProviderOrder = Desc(oauthprovider.FieldID)

func newOauthProviderPager(opts []OauthProviderPaginateOption) (*OauthProviderPager, error) {
	pager := &OauthProviderPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultOauthProviderOrder
	}
	return pager, nil
}

func (p *OauthProviderPager) ApplyFilter(query *OauthProviderQuery) (*OauthProviderQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// OauthProviderPageList is OauthProvider PageList result.
type OauthProviderPageList struct {
	List        []*OauthProvider `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

func (op *OauthProviderQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...OauthProviderPaginateOption,
) (*OauthProviderPageList, error) {

	pager, err := newOauthProviderPager(opts)
	if err != nil {
		return nil, err
	}

	if op, err = pager.ApplyFilter(op); err != nil {
		return nil, err
	}

	ret := &OauthProviderPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := op.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		op = op.Order(pager.Order)
	} else {
		op = op.Order(DefaultOauthProviderOrder)
	}

	op = op.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := op.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type ServicePager struct {
	Order  service.OrderOption
	Filter func(*ServiceQuery) (*ServiceQuery, error)
}

// ServicePaginateOption enables pagination customization.
type ServicePaginateOption func(*ServicePager)

// DefaultServiceOrder is the default ordering of Service.
var DefaultServiceOrder = Desc(service.FieldID)

func newServicePager(opts []ServicePaginateOption) (*ServicePager, error) {
	pager := &ServicePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultServiceOrder
	}
	return pager, nil
}

func (p *ServicePager) ApplyFilter(query *ServiceQuery) (*ServiceQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ServicePageList is Service PageList result.
type ServicePageList struct {
	List        []*Service   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (s *ServiceQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...ServicePaginateOption,
) (*ServicePageList, error) {

	pager, err := newServicePager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.ApplyFilter(s); err != nil {
		return nil, err
	}

	ret := &ServicePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := s.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		s = s.Order(pager.Order)
	} else {
		s = s.Order(DefaultServiceOrder)
	}

	s = s.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type SwiperPager struct {
	Order  swiper.OrderOption
	Filter func(*SwiperQuery) (*SwiperQuery, error)
}

// SwiperPaginateOption enables pagination customization.
type SwiperPaginateOption func(*SwiperPager)

// DefaultSwiperOrder is the default ordering of Swiper.
var DefaultSwiperOrder = Desc(swiper.FieldID)

func newSwiperPager(opts []SwiperPaginateOption) (*SwiperPager, error) {
	pager := &SwiperPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultSwiperOrder
	}
	return pager, nil
}

func (p *SwiperPager) ApplyFilter(query *SwiperQuery) (*SwiperQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// SwiperPageList is Swiper PageList result.
type SwiperPageList struct {
	List        []*Swiper    `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (s *SwiperQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...SwiperPaginateOption,
) (*SwiperPageList, error) {

	pager, err := newSwiperPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.ApplyFilter(s); err != nil {
		return nil, err
	}

	ret := &SwiperPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := s.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		s = s.Order(pager.Order)
	} else {
		s = s.Order(DefaultSwiperOrder)
	}

	s = s.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type TokenPager struct {
	Order  token.OrderOption
	Filter func(*TokenQuery) (*TokenQuery, error)
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*TokenPager)

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = Desc(token.FieldID)

func newTokenPager(opts []TokenPaginateOption) (*TokenPager, error) {
	pager := &TokenPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *TokenPager) ApplyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// TokenPageList is Token PageList result.
type TokenPageList struct {
	List        []*Token     `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (t *TokenQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...TokenPaginateOption,
) (*TokenPageList, error) {

	pager, err := newTokenPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.ApplyFilter(t); err != nil {
		return nil, err
	}

	ret := &TokenPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	query := t.Clone()
	query.ctx.Fields = nil
	count, err := query.Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		t = t.Order(pager.Order)
	} else {
		t = t.Order(DefaultTokenOrder)
	}

	t = t.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
